# âš™ï¸ Challenge: Ethernaut â€“ 05.Token

## ğŸ“œ Description / åŸé¢˜æè¿°

> The goal of this level is for you to hack the basic token contract below.

> You are given 20 tokens to start with and you will beat the level if you somehow manage to get your hands on any additional tokens. Preferably a very large amount of tokens.

> Things that might help:

> What is an odometer?

---

## ğŸ¤” Exploit Idea: overflow / æ¼æ´æ€è·¯ï¼šæº¢å‡º

### The prompt told me that I should increase the token and I only have 20.

### Then the `transfer()` is the only function that operate the variable `balances`.

### Seeing the version of solidity is `pragma solidity ^0.6.0`, so there must be some old exploits can use.

### This condition only need `result >= 0`, so maybe the overflow would works.

### If the `balances[msg.sender]` minus a number that is bigger than itself, then the result will be the max number of Uint 256 cause the overflow.

### So that the balance of the owner will increase.

```javascript
require(balances[msg.sender] - _value >= 0);
balances[msg.sender] -= _value;
```

---

## ğŸ§  Concept Summary / æ¦‚å¿µæ€»ç»“

### `uint256` is an unsigned integer type, which means it does not include negative numbers. So if `uint256 a = 1;`, then performing a - 2 will cause an underflow and result in the maximum value of uint256.

---

## ğŸ”¬Proof of Concept / æ¦‚å¿µè¯æ˜

### 1ã€Call transfer function use a value of 21.

---

## ğŸ“Notes

###

- Solidity v0.6.0 preâ€‘0.8 would no do the overflow/underflow check.
